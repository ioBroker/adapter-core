{
  "version": 3,
  "sources": ["../esm/TokenRefresher.js"],
  "sourcesContent": ["/**\n * This file implements a TokenRefresher class that manages OAuth2 access tokens for an ioBroker adapter.\n *\n * Instructions: https://github.com/ioBroker/ioBroker.admin/blob/master/packages/jsonConfig/OAUTH2.md\n */\nimport axios from 'axios';\nexport class TokenRefresher {\n    adapter;\n    stateName;\n    refreshTokenTimeout;\n    accessToken;\n    url;\n    readyPromise;\n    name;\n    /**\n     * Creates an instance of TokenRefresher.\n     * @param adapter Instance of ioBroker adapter\n     * @param serviceName Name of the service for which the tokens are managed, e.g., 'spotify', 'dropbox', etc.\n     * @param stateName Optional name of the state where tokens are stored. Defaults to 'oauth2Tokens' and that will store tokens in `ADAPTER.X.oauth2Tokens`.\n     */\n    constructor(adapter, serviceName, stateName) {\n        this.adapter = adapter;\n        this.stateName = stateName || 'oauth2Tokens';\n        this.url = `https://oauth2.iobroker.in/${serviceName}`;\n        this.name = this.stateName.replace('info.', '').replace('Tokens', '').replace('tokens', '');\n        if (this.name === 'oauth2') {\n            this.name = adapter.name;\n        }\n        this.readyPromise = this.adapter.getForeignStateAsync(`${adapter.namespace}.${this.stateName}`).then(state => {\n            if (state) {\n                this.accessToken = JSON.parse(state.val);\n                if (this.accessToken?.access_token_expires_on &&\n                    new Date(this.accessToken.access_token_expires_on).getTime() < Date.now()) {\n                    this.adapter.log.error('Access token is expired. Please make a authorization again');\n                }\n                else {\n                    this.adapter.log.debug(`Access token for ${this.name} found`);\n                }\n            }\n            else {\n                this.adapter.log.error(`No tokens for ${this.name} found`);\n            }\n            this.adapter\n                .subscribeStatesAsync(this.stateName)\n                .catch(error => this.adapter.log.error(`Cannot read tokens: ${error}`));\n            return this.refreshTokens().catch(error => this.adapter.log.error(`Cannot refresh tokens: ${error}`));\n        });\n    }\n    /**\n     * Destroys the TokenRefresher instance, clearing any timeouts and stopping state subscriptions.\n     */\n    destroy() {\n        if (this.refreshTokenTimeout) {\n            this.adapter.clearTimeout(this.refreshTokenTimeout);\n            this.refreshTokenTimeout = undefined;\n        }\n    }\n    /** This method is called when the state changes for the token.\n     *\n     * @param id ID of the state that changed\n     * @param state Value\n     */\n    onStateChange(id, state) {\n        if (state?.ack && id.endsWith(`.${this.stateName}`)) {\n            if (JSON.stringify(this.accessToken) !== state.val) {\n                try {\n                    this.accessToken = JSON.parse(state.val);\n                    this.refreshTokens().catch(error => this.adapter.log.error(`Cannot refresh tokens: ${error}`));\n                }\n                catch (error) {\n                    this.adapter.log.error(`Cannot parse tokens: ${error}`);\n                    this.accessToken = undefined;\n                }\n            }\n        }\n    }\n    /** Returns the access token if it is valid and not expired.*/\n    async getAccessToken() {\n        await this.readyPromise;\n        if (!this.accessToken?.access_token) {\n            this.adapter.log.error(`No tokens for ${this.name} found`);\n            return undefined;\n        }\n        if (!this.accessToken.access_token_expires_on ||\n            new Date(this.accessToken.access_token_expires_on).getTime() < Date.now()) {\n            this.adapter.log.error('Access token is expired. Please make a authorization again');\n            return undefined;\n        }\n        return this.accessToken.access_token;\n    }\n    async refreshTokens() {\n        if (this.refreshTokenTimeout) {\n            this.adapter.clearTimeout(this.refreshTokenTimeout);\n            this.refreshTokenTimeout = undefined;\n        }\n        if (!this.accessToken?.refresh_token) {\n            this.adapter.log.error(`No tokens for ${this.name} found`);\n            return;\n        }\n        if (!this.accessToken.access_token_expires_on ||\n            new Date(this.accessToken.access_token_expires_on).getTime() < Date.now()) {\n            this.adapter.log.debug('Access token is expired. Retrying to refresh tokens...');\n        }\n        let expiresIn = new Date(this.accessToken.access_token_expires_on).getTime() - Date.now() - 180_000;\n        // If expiration is in less than 3 minutes, refresh the token\n        if (expiresIn <= 0) {\n            // Refresh token\n            try {\n                const response = await axios.post(this.url, this.accessToken);\n                if (response.status !== 200) {\n                    this.adapter.log.error(`Cannot refresh tokens: ${response.statusText}`);\n                    return;\n                }\n                this.accessToken = response.data;\n            }\n            catch (error) {\n                this.adapter.log.error(`Cannot refresh tokens: ${error}`);\n            }\n            if (this.accessToken) {\n                this.accessToken.access_token_expires_on = new Date(Date.now() + this.accessToken.expires_in * 1_000).toISOString();\n                expiresIn = new Date(this.accessToken.access_token_expires_on).getTime() - Date.now() - 180_000;\n                await this.adapter.setState(this.stateName, JSON.stringify(this.accessToken), true);\n                this.adapter.log.debug(`Tokens for ${this.name} updated`);\n            }\n            else {\n                // Try again in 10 minutes\n                expiresIn = 600_000; // 10 minutes\n                this.adapter.log.error(`No tokens for ${this.name} could be refreshed`);\n            }\n        }\n        // no longer than 10 minutes, as longer timer could be not reliable\n        if (expiresIn > 600_000) {\n            expiresIn = 600_000;\n        }\n        else if (expiresIn < 60_000) {\n            expiresIn = 60_000;\n        }\n        this.refreshTokenTimeout = this.adapter.setTimeout(() => {\n            this.refreshTokenTimeout = undefined;\n            this.refreshTokens().catch(error => this.adapter.log.error(`Cannot refresh tokens: ${error}`));\n        }, expiresIn);\n    }\n}\n"],
  "mappings": "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",
  "names": ["axios"]
}
