{
  "version": 3,
  "sources": ["../esm/helpers.js"],
  "sourcesContent": ["import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport { createRequire } from \"node:module\";\nimport * as url from \"node:url\";\n// eslint-disable-next-line unicorn/prefer-module\nvar require = createRequire(import.meta.url || \"file://\" + __filename);\nvar thisDir = url.fileURLToPath(\n// eslint-disable-next-line unicorn/prefer-module\nnew URL(\".\", import.meta.url || \"file://\" + __filename));\n/**\n * Tries to resolve a package using Node.js resolution.\n * Directory names differing from the package name and alternate lookup paths can be passed.\n */\nexport function tryResolvePackage(possiblePaths, lookupPaths) {\n    for (var _i = 0, possiblePaths_1 = possiblePaths; _i < possiblePaths_1.length; _i++) {\n        var pkg = possiblePaths_1[_i];\n        try {\n            // package.json is guaranteed to be in the module root folder\n            // so once that is resolved, take the dirname and we're done\n            var possiblePath = require.resolve(\"\".concat(pkg, \"/package.json\"), (lookupPaths === null || lookupPaths === void 0 ? void 0 : lookupPaths.length) ? { paths: lookupPaths } : undefined);\n            if (fs.existsSync(possiblePath)) {\n                return path.dirname(possiblePath);\n            }\n        }\n        catch (_a) {\n            /* not found */\n        }\n    }\n}\n/**\n * Scans for a package by walking up the directory tree and inspecting package.json\n * Directory names differing from the package name and an alternate start dir can be passed.\n */\nexport function scanForPackage(possiblePaths, startDir) {\n    if (startDir === void 0) { startDir = thisDir; }\n    // We start in the node_modules subfolder of adapter-core, which is the deepest we should be able to expect the controller\n    var curDir = path.join(startDir, \"../node_modules\");\n    while (true) {\n        for (var _i = 0, possiblePaths_2 = possiblePaths; _i < possiblePaths_2.length; _i++) {\n            var pkg = possiblePaths_2[_i];\n            var possiblePath = path.join(curDir, pkg, \"package.json\");\n            try {\n                // If package.json exists in the directory and its name field matches, we've found js-controller\n                if (fs.existsSync(possiblePath) &&\n                    JSON.parse(fs.readFileSync(possiblePath, \"utf8\")).name ===\n                        pkg.toLowerCase()) {\n                    return path.dirname(possiblePath);\n                }\n            }\n            catch (_a) {\n                // don't care\n            }\n        }\n        // Nothing found here, go up one level\n        var parentDir = path.dirname(curDir);\n        if (parentDir === curDir) {\n            // we've reached the root without finding js-controller\n            break;\n        }\n        curDir = parentDir;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,WAAsB;AACtB,yBAA8B;AAC9B,UAAqB;AAHrB;AAKA,IAAIA,eAAU,kCAAc,YAAY,OAAO,YAAY,UAAU;AACrE,IAAI,UAAU,IAAI;AAAA,EAElB,IAAI,IAAI,KAAK,YAAY,OAAO,YAAY,UAAU;AAAC;AAKhD,SAAS,kBAAkB,eAAe,aAAa;AAC1D,WAAS,KAAK,GAAG,kBAAkB,eAAe,KAAK,gBAAgB,QAAQ,MAAM;AACjF,QAAI,MAAM,gBAAgB;AAC1B,QAAI;AAGA,UAAI,eAAeA,SAAQ,QAAQ,GAAG,OAAO,KAAK,eAAe,IAAI,gBAAgB,QAAQ,gBAAgB,SAAS,SAAS,YAAY,UAAU,EAAE,OAAO,YAAY,IAAI,MAAS;AACvL,UAAI,GAAG,WAAW,YAAY,GAAG;AAC7B,eAAO,KAAK,QAAQ,YAAY;AAAA,MACpC;AAAA,IACJ,SACO,IAAP;AAAA,IAEA;AAAA,EACJ;AACJ;AAKO,SAAS,eAAe,eAAe,UAAU;AACpD,MAAI,aAAa,QAAQ;AAAE,eAAW;AAAA,EAAS;AAE/C,MAAI,SAAS,KAAK,KAAK,UAAU,iBAAiB;AAClD,SAAO,MAAM;AACT,aAAS,KAAK,GAAG,kBAAkB,eAAe,KAAK,gBAAgB,QAAQ,MAAM;AACjF,UAAI,MAAM,gBAAgB;AAC1B,UAAI,eAAe,KAAK,KAAK,QAAQ,KAAK,cAAc;AACxD,UAAI;AAEA,YAAI,GAAG,WAAW,YAAY,KAC1B,KAAK,MAAM,GAAG,aAAa,cAAc,MAAM,CAAC,EAAE,SAC9C,IAAI,YAAY,GAAG;AACvB,iBAAO,KAAK,QAAQ,YAAY;AAAA,QACpC;AAAA,MACJ,SACO,IAAP;AAAA,MAEA;AAAA,IACJ;AAEA,QAAI,YAAY,KAAK,QAAQ,MAAM;AACnC,QAAI,cAAc,QAAQ;AAEtB;AAAA,IACJ;AACA,aAAS;AAAA,EACb;AACJ;",
  "names": ["require"]
}
